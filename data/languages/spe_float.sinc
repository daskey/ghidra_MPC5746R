# SPE Floating Point Instructions

define pcodeop max_float;
define pcodeop min_float;

# efsmin rT,rA,rB      010 1100 1010
:efsmin D,A,B is OP=4 & D & A & B & XOP_0_10=0x2B1
{
    local result:4 = min_float(A:4, B:4);
    D = (D & 0xFFFFFFFF00000000) | zext(result);
    setSummaryFPSCR();
}

# efsmax rT,rA,rB      010 1100 1011
:efsmax D,A,B is OP=4 & D & A & B & XOP_0_10=0x2b0
{
    local result:4 = max_float(A:4, B:4);
    D = (D & 0xFFFFFFFF00000000) | zext(result);
    setSummaryFPSCR();
}

# VLE Special Load/Store Instructions
:e_lmvgprw   is OP=4 & XOP_0_10=0x207 {
    # Load Multiple GPR Words
}

:e_lmvmcsrrw is OP=4 & XOP_0_10=0x208 {
    # Load Multiple MCSR Words
}

:e_lmvsprw   is OP=4 & XOP_0_10=0x209 {
    # Load Multiple SPR Words
}

:e_stmvmcsrrw is OP=4 & XOP_0_10=0x20A {
    # Store Multiple MCSR Words
}

:se_nop      is OP=1 & XOP_0_5=0x00 {
    # SE no operation
}

# VLE Arithmetic Instructions
# e_addbus - Add Byte Unsigned
:e_addbus D, A, B is OP=31 & D & A & B & XOP_0_10=0x7D4
{
    local result:1 = (A:1 + B:1) & 0xFF;
    D = zext(result);
}

# e_addhus - Add Halfword Unsigned Saturate
:e_addhus D, A, B is OP=31 & D & A & B & XOP_0_10=0x754 & Rc=0 {
    local a;
    local b;
    local sum;

    a = A & 0xFFFF;          # Extract lower 16 bits of A
    b = B & 0xFFFF;          # Extract lower 16 bits of B
    sum = a + b;             # Sum of a and b

    if (sum > 0xFFFF) goto <saturate>;
    D = sum;
    goto <done>;

<saturate>
    D = 0xFFFF;

<done>
}

# e_addwus - Add Word Unsigned
:e_addwus D, A, B is OP=31 & D & A & B & XOP_0_10=0x6D4
{
    local result:$(REGISTER_SIZE) = A + B;
    D = result;
}

# e_subfbus - Subtract Byte Unsigned
:e_subfbus D, A, B is OP=31 & D & A & B & XOP_0_10=0x7d0
{
    local a:1 = A:1;
    local b:1 = B:1;
    local result:1 = b - a;
    D = zext(result);
}

# e_subfhus - Subtract Halfword Unsigned Saturate
:e_subfhus D, A, B is OP=31 & D & A & B & XOP_0_10=0x750
{
    local a:2 = A:2;
    local b:2 = B:2;
    local result:2 = b - a;
    if (b < a) goto <saturate>;
    goto <done>;
    <saturate>
    result = 0;
    <done>
    D = zext(result);
}

:e_nop       is OP=4 & XOP_0_10=0x000 {
    # VLE no operation
}

# binutils-descr: "lbdx",    X(31,515),    X_MASK,      E500MC,    PPCNONE,    {RT, RA, RB}
define pcodeop lbdxOp;
# ISA-info: lbdx - Form "X" Page 708 Category "DS"
# binutils: e500mc.d:   68:    7c 01 14 06     lbdx    r0,r1,r2
:lbdx RT,A,B is OP=31 & XOP_1_10=515 & RT & A & B & BIT_0=0  { RT = lbdxOp(RT,A,B); }

:mpusync is OP=31 & XOP_0_10=1132 & Rc=0 {
}

# These instructions show up in the Freescale PowerQUICC III instruction manual
# (not present elsewhere)
 
define pcodeop dataCacheBlockClearLock;
define pcodeop prefetchDataCacheBlockLockSet;
define pcodeop prefetchDataCacheBlockLockSetX;
define pcodeop debuggerNotifyHalt;
define pcodeop instructionCacheBlockClearLock;
define pcodeop queryInstructionCacheBlockLock;
define pcodeop prefetchInstructionCacheBlockLockSetX;
define pcodeop moveFromAPIDIndirect;
define pcodeop moveFromPerformanceMonitorRegister;
define pcodeop moveToPerformanceMonitorRegister;
define pcodeop invalidateTLB;

#dcblc 0,0,r0        #FIXME
:dcblc CT,RA_OR_ZERO,B    is OP=31 & CT & B & XOP_1_10=390 & BIT_0=0 & RA_OR_ZERO
{
        ea:$(REGISTER_SIZE) = RA_OR_ZERO + B;
    dataCacheBlockClearLock(ea);
}

#dcbtls 0,0,r0        #FIXME
:dcbtls CT,RA_OR_ZERO,B    is OP=31 & CT & B & XOP_1_10=166 & BIT_0=0 & RA_OR_ZERO
{
        ea:$(REGISTER_SIZE) = RA_OR_ZERO + B;
    prefetchDataCacheBlockLockSet(ea);
}

#dcbtstls 0,0,r0        #FIXME
:dcbtstls CT,RA_OR_ZERO,B    is OP=31 & CT & B & XOP_1_10=134 & BIT_0=0 & RA_OR_ZERO
{
        ea:$(REGISTER_SIZE) = RA_OR_ZERO + B;
    prefetchDataCacheBlockLockSetX(ea);
}

#dnh 0,0        #FIXME
:dnh DUI,DUIS    is $(NOTVLE) & OP=19 & DUI & DUIS & XOP_1_10=198 & BIT_0=0
{
    debuggerNotifyHalt(DUI:1,DUIS:2);
}

#icblc 0,0,r0        #FIXME
:icblc CT,RA_OR_ZERO,B    is OP=31 & CT & B & XOP_1_10=230 & BIT_0=0 & RA_OR_ZERO
{
        ea:$(REGISTER_SIZE) = RA_OR_ZERO + B;
    instructionCacheBlockClearLock(CT:1,ea);
}

:icblq CT,RA_OR_ZERO,B    is OP=31 & CT & B & XOP_1_10=198 & BIT_0=1 & RA_OR_ZERO
{
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + B;
    cr0 = queryInstructionCacheBlockLock(CT:1,ea);
}

#icbtls 0,0,r0        #FIXME
:icbtls CT,RA_OR_ZERO,B    is OP=31 & CT & B & XOP_1_10=486 & BIT_0=0 & RA_OR_ZERO
{
        ea:$(REGISTER_SIZE) = RA_OR_ZERO + B;
    prefetchInstructionCacheBlockLockSetX(ea);
}

:isel^CC_X_OPm D,RA_OR_ZERO,B,CC_X_OP  is OP=31 & D & RA_OR_ZERO & B & CC_X_OP & CC_X_OPm & XOP_1_5=15
{
    local tmp:$(REGISTER_SIZE) = RA_OR_ZERO;
    D = B;
    if (!CC_X_OP) goto inst_next;
    D = tmp;
#        D = (zext(CC_X_OP) * RA_OR_ZERO) + (zext(!CC_X_OP) * B);
}

#mfapidi r0,r1  #FIXME
:mfapidi D,A    is $(NOTVLE) & OP=31 & D & A & XOP_1_10=275
{ 
    D = moveFromAPIDIndirect(A);
}

pmrn: pmr       is BITS_16_20 & BITS_11_15 [ pmr = BITS_11_15 << 5 | BITS_16_20; ] { tmp:2 = pmr; export tmp; }

#mfpmr r0,?     #FIXME
:mfpmr D,pmrn   is OP=31 & D & pmrn & XOP_1_10=334 & BIT_0=0
{ 
    D = moveFromPerformanceMonitorRegister(pmrn);
}

#mtpmr r0,?     #FIXME
:mtpmr pmrn,S   is OP=31 & S & pmrn & XOP_1_10=462 & BIT_0=0
{ 
    moveToPerformanceMonitorRegister(pmrn, S);
}

#rfdi           #FIXME
:rfdi           is $(NOTVLE) & OP=19 & XOP_1_10=39
{ 
    MSR = returnFromDebugInterrupt(MSR, spr23f); #DSRR1
    local ra = spr23e; #DSRR0
    return[ra];
}

#rfmci          #FIXME
:rfmci          is $(NOTVLE) & OP=19 & XOP_0_10=76
{ 
    MSR = returnFromMachineCheckInterrupt(MSR, spr23b); #MCSRR1
    local ra = spr23a; #MCSRR0
    return[ra];
}


# PowerISA II: 6.11.4.9 TLB Management Instructions
# CMT: TLB Invalidate Local Indexed [Category: Embedded.Phased In]]
# FORM: X-form
define pcodeop TLBInvalidateLocalIndexed; # Outputs/affect TBD
:tlbilx BITS_21_22,RA_OR_ZERO,RB_OR_ZERO is $(NOTVLE) & OP=31 & CRFD=0 & BITS_21_22 & RA_OR_ZERO & RB_OR_ZERO & XOP_1_10=18 & BIT_0=0 { 
    TLBInvalidateLocalIndexed(BITS_21_22:1,RA_OR_ZERO,RB_OR_ZERO);
}

#tlbivax 0,r0           #FIXME
:tlbivax RA_OR_ZERO,B    is OP=31 & RA_OR_ZERO & B & XOP_1_10=786
{
        ea:$(REGISTER_SIZE) = RA_OR_ZERO + B;
    invalidateTLB(ea);
}