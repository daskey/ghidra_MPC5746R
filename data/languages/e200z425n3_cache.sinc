# e200z425n3 Core Specific Cache and Memory Management Instructions
# Based on e200z425n3 Reference Manual

# Cache management pcodeops
define pcodeop cacheBlockTouch;
define pcodeop cacheBlockStore;
define pcodeop cacheBlockFlush;
define pcodeop cacheBlockInvalidate;
define pcodeop cacheBlockZero;
define pcodeop cacheBlockAllocate;

# Data Cache Block Touch
:dcbt RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=278 & BIT_0=0
{
    # Data cache block touch - hint for prefetch
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    # Implementation: Request cache line containing EA for future load access
    # This is a hint instruction, no architectural effect on program correctness
    cacheBlockTouch($(EATRUNC));
}

# Data Cache Block Touch for Store
:dcbtst RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=246 & BIT_0=0
{
    # Data cache block touch for store - hint for prefetch with intent to modify
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    cacheBlockTouch($(EATRUNC));
}

# Data Cache Block Store
:dcbst RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=54 & BIT_0=0
{
    # Force dirty cache block to be written to memory
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    cacheBlockStore($(EATRUNC));
}

# Data Cache Block Flush
:dcbf RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=86 & BIT_0=0
{
    # Force dirty cache block to memory and invalidate
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    cacheBlockFlush($(EATRUNC));
}

# Data Cache Block Invalidate
:dcbi RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=470 & BIT_0=0
{
    # Invalidate cache block (privileged)
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    cacheBlockInvalidate($(EATRUNC));
}

# Instruction Cache Block Invalidate
:icbi RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=982 & BIT_0=0
{
    # Invalidate instruction cache block
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    instructionCacheBlockInvalidate($(EATRUNC));
}

# Data Cache Block Zero
:dcbz RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=1014 & BIT_0=0
{
    # Clear cache block to zeros (typically 32 bytes on e200z425n3)
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    local aligned_ea:$(REGISTER_SIZE) = ea & 0xFFFFFFE0; # Align to 32-byte boundary
    
    # Clear 32 bytes (8 words) starting at aligned address
    *:4 (aligned_ea) = 0;
    *:4 (aligned_ea + 4) = 0;
    *:4 (aligned_ea + 8) = 0;
    *:4 (aligned_ea + 12) = 0;
    *:4 (aligned_ea + 16) = 0;
    *:4 (aligned_ea + 20) = 0;
    *:4 (aligned_ea + 24) = 0;
    *:4 (aligned_ea + 28) = 0;
}

# Data Cache Block Allocate
:dcba RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=758 & BIT_0=0
{
    # Allocate cache block without reading from memory
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    cacheBlockAllocate($(EATRUNC));
}

# e200z425n3 specific L2 cache instructions
define pcodeop l2CacheFlush;
define pcodeop l2CacheInvalidate;

# L2 Cache Flush All
:dcbfl2 RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=774 & BIT_0=0
{
    # L2 cache flush (if present)
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    l2CacheFlush($(EATRUNC));
}

# L2 Cache Invalidate All
:dcbil2 RA_OR_ZERO,RB is OP=31 & RA_OR_ZERO & RB & XOP_1_10=838 & BIT_0=0
{
    # L2 cache invalidate (if present)
    ea:$(REGISTER_SIZE) = RA_OR_ZERO + RB;
    l2CacheInvalidate($(EATRUNC));
}